#-------------------------------------------
shuffleData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
z[,3] <- sample(z[,3])
return(z)
}
shuffleData()
###############################################
#FUNCTION: getPVal
#calculate p value for observed, simulated data
#input: list of observed metric and vector of simulated metric,
#output: lower, upper tail probability vector
#---------------------------------------------
getPval <- function(z=NULL) {
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
pLower <- mean(z[[2]] <=z[[1]])
pUpper <- mean(z[[2]] >=z[[1]])
return(c(pL=pLower, pU= pUpper))
}
getPval()
#----------------------------------------------------------------
#main body of code
nSim <- 100 # number of simulations
Xsim <- rep(NA, nSim) #will hold simulated slopes
dF <- readData()
Xobs <- getMetric(dF)
for (i in seq_len(nSim)) {
Xsim[i] <- getMetric(shuffleData(dF)) }
slopes <- list(Xobs,Xsim)
getPval(slopes)
###############################################################
# FUNCTION: plotRanTest
# ggplot graph
# input: list of observed metric and vector of the simulated metric
# output: ggplot graph
#---------------------------------------------------------------
plotRantTest <- function(z=NULL){
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
df <- data.frame(ID= seq_along(z[[2]]),
simX=z[[2]])
p1 <- ggplot(data=df, mapping=aes(x=simX))
p1 + geom_histogram(mapping=aes(fill=I("mistyrose1"), color=I("black"))) +
geom_vline(aes(xintercept=z[[1]], col="blue"))
}
plotRantTest()
#preliminaries
library(ggplot2)
library(TeachingDemos)
char2seed("Cruel April")
#############################################
#FUNCTION: readData
# read in or generate data frame, will get changed most when you work with it in future
# input filename (or nothing for demo)
#output: 3-column data frame of observed data:
#dat:(ID,x,y)
#--------------------------------------------------
readData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
dF <- data.frame(ID=seq_along
(xVar), xVar, yVar)
return(dF)}
}
#preliminary data on AMF colonization regression, imcomlete, but I think it'll work for this purpose. X is icing treatment (mm thick of ice, and y is AMF structures/cm
readData()
################################################
# FUNCTION: getMetric
# claculate metric for randomization test
#input 3-column data frame for regression
#ouput: regression slope
#------------------------------------------------
getMetric <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
. <- lm(z[,3]~z[,2])
. <- summary(.)
. <- .$coefficients[2,1]
slope <- .
return(slope)
}
getMetric()
#################################################
#FUNCTION: shuffleData
# randomize data for regression data analysis
# input 3-column data frame for regression
# output 3-column data frame for regression
#-------------------------------------------
shuffleData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
z[,3] <- sample(z[,3])
return(z)
}
shuffleData()
###############################################
#FUNCTION: getPVal
#calculate p value for observed, simulated data
#input: list of observed metric and vector of simulated metric,
#output: lower, upper tail probability vector
#---------------------------------------------
getPval <- function(z=NULL) {
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
pLower <- mean(z[[2]] <=z[[1]])
pUpper <- mean(z[[2]] >=z[[1]])
return(c(pL=pLower, pU= pUpper))
}
getPval()
#----------------------------------------------------------------
#main body of code
nSim <-2000 # number of simulations
Xsim <- rep(NA, nSim) #will hold simulated slopes
dF <- readData()
Xobs <- getMetric(dF)
for (i in seq_len(nSim)) {
Xsim[i] <- getMetric(shuffleData(dF)) }
slopes <- list(Xobs,Xsim)
getPval(slopes)
###############################################################
# FUNCTION: plotRanTest
# ggplot graph
# input: list of observed metric and vector of the simulated metric
# output: ggplot graph
#---------------------------------------------------------------
plotRantTest <- function(z=NULL){
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
df <- data.frame(ID= seq_along(z[[2]]),
simX=z[[2]])
p1 <- ggplot(data=df, mapping=aes(x=simX))
p1 + geom_histogram(mapping=aes(fill=I("mistyrose1"), color=I("black"))) +
geom_vline(aes(xintercept=z[[1]], col="blue"))
}
plotRantTest()
#preliminaries
library(ggplot2)
library(TeachingDemos)
char2seed("Cruel April")
#############################################
#FUNCTION: readData
# read in or generate data frame, will get changed most when you work with it in future
# input filename (or nothing for demo)
#output: 3-column data frame of observed data:
#dat:(ID,x,y)
#--------------------------------------------------
readData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
dF <- data.frame(ID=seq_along
(xVar), xVar, yVar)
return(dF)}
}
#preliminary data on AMF colonization regression, imcomlete, but I think it'll work for this purpose. X is icing treatment (mm thick of ice, and y is AMF structures/cm
readData()
################################################
# FUNCTION: getMetric
# claculate metric for randomization test
#input 3-column data frame for regression
#ouput: regression slope
#------------------------------------------------
getMetric <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
. <- lm(z[,3]~z[,2])
. <- summary(.)
. <- .$coefficients[2,1]
slope <- .
return(slope)
}
getMetric()
#################################################
#FUNCTION: shuffleData
# randomize data for regression data analysis
# input 3-column data frame for regression
# output 3-column data frame for regression
#-------------------------------------------
shuffleData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
z[,3] <- sample(z[,3])
return(z)
}
shuffleData()
###############################################
#FUNCTION: getPVal
#calculate p value for observed, simulated data
#input: list of observed metric and vector of simulated metric,
#output: lower, upper tail probability vector
#---------------------------------------------
getPval <- function(z=NULL) {
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
pLower <- mean(z[[2]] <=z[[1]])
pUpper <- mean(z[[2]] >=z[[1]])
return(c(pL=pLower, pU= pUpper))
}
getPval()
#----------------------------------------------------------------
#main body of code
nSim <-1000 # number of simulations
Xsim <- rep(NA, nSim) #will hold simulated slopes
dF <- readData()
Xobs <- getMetric(dF)
for (i in seq_len(nSim)) {
Xsim[i] <- getMetric(shuffleData(dF)) }
slopes <- list(Xobs,Xsim)
getPval(slopes)
###############################################################
# FUNCTION: plotRanTest
# ggplot graph
# input: list of observed metric and vector of the simulated metric
# output: ggplot graph
#---------------------------------------------------------------
plotRantTest <- function(z=NULL){
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
df <- data.frame(ID= seq_along(z[[2]]),
simX=z[[2]])
p1 <- ggplot(data=df, mapping=aes(x=simX))
p1 + geom_histogram(mapping=aes(fill=I("mistyrose1"), color=I("black"))) +
geom_vline(aes(xintercept=z[[1]], col="blue"))
}
plotRantTest()
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
ID <- seq_along(xVar)
RegData <- data.frame(ID, xVar, yVar)
head(RegData)
str(regData)
#model
regModel <-lm(yVar~xVar, data=RegData)
#model output
summary(regModel)
#preliminaries
library(ggplot2)
library(TeachingDemos)
char2seed("Cruel April")
#############################################
#FUNCTION: readData
# read in or generate data frame, will get changed most when you work with it in future
# input filename (or nothing for demo)
#output: 3-column data frame of observed data:
#dat:(ID,x,y)
#--------------------------------------------------
readData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
dF <- data.frame(ID=seq_along
(xVar), xVar, yVar)
return(dF)}
}
#preliminary data on AMF colonization regression, imcomlete, but I think it'll work for this purpose. X is icing treatment (mm thick of ice, and y is AMF structures/cm
readData()
################################################
# FUNCTION: getMetric
# claculate metric for randomization test
#input 3-column data frame for regression
#ouput: regression slope
#------------------------------------------------
getMetric <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
. <- lm(z[,3]~z[,2])
. <- summary(.)
. <- .$coefficients[2,1]
slope <- .
return(slope)
}
getMetric()
#################################################
#FUNCTION: shuffleData
# randomize data for regression data analysis
# input 3-column data frame for regression
# output 3-column data frame for regression
#-------------------------------------------
shuffleData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
z[,3] <- sample(z[,3])
return(z)
}
shuffleData()
###############################################
#FUNCTION: getPVal
#calculate p value for observed, simulated data
#input: list of observed metric and vector of simulated metric,
#output: lower, upper tail probability vector
#---------------------------------------------
getPval <- function(z=NULL) {
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
pLower <- mean(z[[2]] <=z[[1]])
pUpper <- mean(z[[2]] >=z[[1]])
return(c(pL=pLower, pU= pUpper))
}
getPval()
#----------------------------------------------------------------
#main body of code
nSim <-2000 # number of simulations
Xsim <- rep(NA, nSim) #will hold simulated slopes
dF <- readData()
Xobs <- getMetric(dF)
for (i in seq_len(nSim)) {
Xsim[i] <- getMetric(shuffleData(dF)) }
slopes <- list(Xobs,Xsim)
getPval(slopes)
###############################################################
# FUNCTION: plotRanTest
# ggplot graph
# input: list of observed metric and vector of the simulated metric
# output: ggplot graph
#---------------------------------------------------------------
plotRantTest <- function(z=NULL){
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
df <- data.frame(ID= seq_along(z[[2]]),
simX=z[[2]])
p1 <- ggplot(data=df, mapping=aes(x=simX))
p1 + geom_histogram(mapping=aes(fill=I("mistyrose1"), color=I("black"))) +
geom_vline(aes(xintercept=z[[1]], col="blue"))
}
plotRantTest()
#preliminaries
library(ggplot2)
library(TeachingDemos)
char2seed("Cruel April")
#############################################
#FUNCTION: readData
# read in or generate data frame, will get changed most when you work with it in future
# input filename (or nothing for demo)
#output: 3-column data frame of observed data:
#dat:(ID,x,y)
#--------------------------------------------------
readData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
dF <- data.frame(ID=seq_along
(xVar), xVar, yVar)
return(dF)}
}
#preliminary data on AMF colonization regression, imcomlete, but I think it'll work for this purpose. X is icing treatment (mm thick of ice, and y is AMF structures/cm
readData()
################################################
# FUNCTION: getMetric
# claculate metric for randomization test
#input 3-column data frame for regression
#ouput: regression slope
#------------------------------------------------
getMetric <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
. <- lm(z[,3]~z[,2])
. <- summary(.)
. <- .$coefficients[2,1]
slope <- .
return(slope)
}
getMetric()
#################################################
#FUNCTION: shuffleData
# randomize data for regression data analysis
# input 3-column data frame for regression
# output 3-column data frame for regression
#-------------------------------------------
shuffleData <- function(z=NULL){
if(is.null(z)){
xVar <- c(0,6,13,19)
yVar <- c(8.947,8.289,6.346,3.766)
z <- data.frame(ID=seq_along
(xVar), xVar, yVar)}
z[,3] <- sample(z[,3])
return(z)
}
shuffleData()
###############################################
#FUNCTION: getPVal
#calculate p value for observed, simulated data
#input: list of observed metric and vector of simulated metric,
#output: lower, upper tail probability vector
#---------------------------------------------
getPval <- function(z=NULL) {
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
pLower <- mean(z[[2]] <=z[[1]])
pUpper <- mean(z[[2]] >=z[[1]])
return(c(pL=pLower, pU= pUpper))
}
getPval()
#----------------------------------------------------------------
#main body of code
nSim <- 10000 # number of simulations
Xsim <- rep(NA, nSim) #will hold simulated slopes
dF <- readData()
Xobs <- getMetric(dF)
for (i in seq_len(nSim)) {
Xsim[i] <- getMetric(shuffleData(dF)) }
slopes <- list(Xobs,Xsim)
getPval(slopes)
###############################################################
# FUNCTION: plotRanTest
# ggplot graph
# input: list of observed metric and vector of the simulated metric
# output: ggplot graph
#---------------------------------------------------------------
plotRantTest <- function(z=NULL){
if(is.null(z)){
z <- list(xObs=runif(1), xSim=runif(1000))}
df <- data.frame(ID= seq_along(z[[2]]),
simX=z[[2]])
p1 <- ggplot(data=df, mapping=aes(x=simX))
p1 + geom_histogram(mapping=aes(fill=I("mistyrose1"), color=I("black"))) +
geom_vline(aes(xintercept=z[[1]], col="blue"))
}
plotRantTest()
# Hyphal Lenght analysis
# 27 March 2018
# CEY
# The equation: HL = ll/14*N*g gives you hyphal root length
##################################################
# FUNCTION: HyphaeLen
# determines average hyphae root length in a soil sample
# input: N = number of intersections across vertical and horizontal lines
#        g= gird unit length of section (cm)
#        C = predetermined constant (done by Tennet, 1975
# output: root length
#-------------------------------------------------
HyphaeLen <- function(N=20:200,c=(11/14),g=.05){
HL <-N*c*g
return(HL)
}
head(HyphaeLen())
#######################
# FUNCTION: HyphaeLenPlot
# plot hyphae length curves with parameter values
# input: N= number of intersections across vertical and horizontal lines
#       g= grid unit length (cm)
#       c= predetermined constant (done by Tennet 1975)
#output: smoothed curve with parameters in the graph
#-----------------------------------------
HyphaeLenPlot <- function(N=20:200, c=11/14, g=0.05){
plot(x=N,y=HyphaeLen(N,g,c),type="l",xlab="Intersections",ylab="S",ylim=c(0,2500))
mtext(paste("g =", g,"  c =",c),cex=0.7)
return()
}
HyphaeLenPlot()
#######################
# FUNCTION: HyphaeLenPlot
# plot hyphae length curves with parameter values
# input: N= number of intersections across vertical and horizontal lines
#       g= grid unit length (cm)
#       c= predetermined constant (done by Tennet 1975)
#output: smoothed curve with parameters in the graph
#-----------------------------------------
HyphaeLenPlot <- function(N=20:200, c=11/14, g=0.05){
plot(x=N,y=HyphaeLen(N,g,c),type="l",xlab="Intersections",ylab="S",ylim=c(0,10))
mtext(paste("g =", g,"  c =",c),cex=0.7)
return()
}
HyphaeLenPlot()
gPars <- c(.01, .03, .05)
cPars <- c(8/14, 10/14, 11/14, 13/14)
par(mfrow=c(3,4))
for(i in seq_along(gPars)){
for(j in seq_along(cPars)){
HyphaeLenPlot(g=gPars[i], c=cPars[j])
}
}
gPars <- c(100,150,175)
cPars <- c(0.1,0.16,0.26,0.3)
Number <- 1:5
#set up model frame
modelFrame <- expand.grid(g=gPars,c=cPars,N=Number)
modelFrame$S <- NA
# Loop tricky
for (i in 1:length(gPars)){
for(j in 1:length(cPars)){
modelFrame[modelFrame$g==gPars[i] & modelFrame$c==cPars[j], "S"] <-HyphaeLenPlot(N=Number,
g=gPars[i],
c=cPars[j])
} #close c par loop
} #close g par loop
